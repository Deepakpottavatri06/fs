Question-1:
You have the following code:

ExecutorService executor = Executors.newFixedThreadPool(1);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 42;
});

System.out.println(future.get());
executor.shutdown();


Which statement is true?




Question-2:

class Shared {
    synchronized void doWork() throws InterruptedException {
        System.out.print("Start ");
        wait();
        System.out.print("End ");
    }
}

Shared s = new Shared();
new Thread(() -> {
    try { s.doWork(); } catch (Exception e) {}
}).start();
Thread.sleep(500);
s.notify();

What is the output?



Question-3:
class Shared {
    synchronized void doWait() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " waiting");
        wait();
        System.out.println(Thread.currentThread().getName() + " resumed");
    }
}
Shared s = new Shared();
Runnable r = () -> { try { s.doWait(); } catch (Exception e) {} };
Thread t1 = new Thread(r, "T1");
Thread t2 = new Thread(r, "T2");
t1.start(); t2.start();

synchronized(s) {
    s.notify();
}

What is guaranteed?



Question-4:

ExecutorService ex = Executors.newSingleThreadExecutor();

Future<String> f = ex.submit(() -> {
    if (true) throw new IllegalStateException("Fail");
    return "Done";
});
try {
    System.out.println(f.get());
} catch (Exception e) {
    System.out.println(e.getClass());
}

ex.shutdown();

What is printed?



Question-5: What is the output?

class Counter {
    private int count = 0;
    public synchronized void increment() {
        count++;
        notifyAll();
    }
    public synchronized void waitForValue(int target) throws InterruptedException {
        while (count < target) {
            wait();
        }
        System.out.println("Reached " + target);
    }
}

Counter c = new Counter();
new Thread(() -> {
    try { c.waitForValue(5); } catch (Exception e) {}
}).start();

for (int i = 0; i < 5; i++) {
    Thread.sleep(100);
    c.increment();
}



Question-6:

final Object A = new Object();
final Object B = new Object();
Thread t1 = new Thread(() -> {
    synchronized (A) {
        sleep(50);
        synchronized (B) { System.out.println("T1 got A then B"); }
    }
});
Thread t2 = new Thread(() -> {
    synchronized (B) {
        sleep(50);
        synchronized (A) { System.out.println("T2 got B then A"); }
    }
});
t1.start(); t2.start();

(Assume sleep wraps Thread.sleep and swallows checked exceptions.)

 What is most accurate?



Question-7: What output pattern is correct?

ExecutorService ex = Executors.newFixedThreadPool(2);

Runnable r1 = () -> {   };
Runnable r2 = () -> { throw new RuntimeException("boom"); };
Callable<String> c1 = () -> "ok";
Callable<String> c2 = () -> { throw new IllegalStateException("bad"); };

Future<?> fr1 = ex.submit(r1);
Future<?> fr2 = ex.submit(r2);
Future<String> fc1 = ex.submit(c1);
Future<String> fc2 = ex.submit(c2);

try { System.out.println(fr1.get()); } catch (Exception e) { System.out.println("R1:" + e); }
try { System.out.println(fr2.get()); } catch (Exception e) { System.out.println("R2:" + e.getClass()); }
try { System.out.println(fc1.get()); } catch (Exception e) { System.out.println("C1:" + e); }
try { System.out.println(fc2.get()); } catch (Exception e) { System.out.println("C2:" + e.getClass()); }

ex.shutdown();



Question-8:  What is printed by the worker thread?

Object lock = new Object();

Thread t = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait();  
            System.out.println("woke normally");
        } catch (InterruptedException e) {
            System.out.println("interrupted");
            System.out.println(Thread.currentThread().isInterrupted());
        }
    }
});
t.start();

Thread.sleep(100);
t.interrupt();


Question-9:    What is true about the behavior?
class Box {
    private boolean ready = false;
    private final Object m1 = new Object();
    private final Object m2 = new Object();

    void awaitReady() throws InterruptedException {
        synchronized (m1) {
            if (!ready) m1.wait();  
        }
        System.out.println("go");
    }
    void signalReady() {
        synchronized (m2) {
            ready = true;
            m2.notifyAll();       
        }
    }
}

Box b = new Box();
new Thread(() -> { try { b.awaitReady(); } catch (Exception ignored) {} }).start();
Thread.sleep(100);
b.signalReady();

// Answers and Explanations:

// Question-1 Answer:
// The code prints 42 after about 1 second.
// Explanation: The submitted task sleeps for 1 second and returns 42. future.get() waits for the result, so 42 is printed after the sleep.

// Question-2 Answer:
// Output: Start (then the program hangs; End is not printed)
// Explanation: s.notify() is called without holding the lock on s, so it throws IllegalMonitorStateException and the waiting thread is never notified.

// Question-3 Answer:
// Only one thread (either T1 or T2) is guaranteed to resume and print its "resumed" message.
// Explanation: Both threads wait, but only one notify is called, so only one thread resumes. Which thread resumes is not guaranteed.

// Question-4 Answer:
// class java.util.concurrent.ExecutionException is printed.
// Explanation: The submitted task throws an exception. f.get() wraps the exception in an ExecutionException, which is caught and its class is printed.

// Question-5 Answer:
// Reached 5 is printed.
// Explanation: The thread waits until count reaches 5. The main thread increments the counter 5 times, notifying all waiting threads each time. When count is 5, the waiting thread prints "Reached 5".

// Question-6 Answer:
// A deadlock may occur.
// Explanation: Both threads acquire one lock and then try to acquire the other. If t1 gets A and t2 gets B, both will wait for the other lock, causing a deadlock.

// Question-7 Answer:
// Output pattern:
// null
// R2: class java.util.concurrent.ExecutionException
// ok
// C2: class java.util.concurrent.ExecutionException
// Explanation: r1 completes normally: null; r2 throws: ExecutionException; c1 returns "ok"; c2 throws: ExecutionException.

// Question-8 Answer:
// interrupted
// true
// Explanation: The worker thread is waiting and gets interrupted. It catches InterruptedException, prints "interrupted", and then prints true (its interrupted status).

// Question-9 Answer:
// The waiting thread will never be notified and will hang.
// Explanation: awaitReady() waits on m1, but signalReady() notifies on m2. The waiting thread is never notified, so it